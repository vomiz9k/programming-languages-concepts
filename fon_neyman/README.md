### Сборка:
```
cmake ./ && make
```

### Запуск:
```
./Assembly [-asm] [-disasm] [-interpret] [--asm_input FILENAME] [--disasm_input FILENAME] [--interpreter_input FILENAME] [--asm_output FILENAME] [--disasm_output FILENAME]
```

### То, что нужно:

```
./Assembly -asm -disasm -interpret --asm_input examples/fib
```

# Про команды:
Большинство команд и их семантика аналогичны командам x86. Отличия:
- Команда IN. Считывает число из stdin
- Команда OUT. Печатает символ в stdout
- Семейство команд JMP и команда CALL требуют двоеточие перед идентификатором метки

Доступные команды и их байткоды можно посмотреть в common/config.cpp

# Про то, что можно поменять/улучшить:
- Добавить секцию .data для более правильной работы с памятью. Сейчас это происходит не супер оптимально, по факту работа со строками есть только в интерпретаторе, в ассемблере нет.
- Можно не заносить целиком названия меток в байткод, можно генерировать айдишники в дизассемблере к примеру. Оставил только для красоты дизассемблера, если это повлияет на мои баллы -- фикс 5-минутный, могу исправить.
- Добавить отдельные команды для работы с данными разной размерности. На данный момент единственный способ скастовать , например, регистр к чему-нибудь меньшей размерности - положить в память и работать оттуда

Зато теперь понял, зачем нужен интеловский синтаксис, который казался неудобным. Подобно тому, как в printf аргументы закидываются в стек задом-наперед, бинарные операции реализовать было бы лаконичнее и проще в синтаксисе интела.